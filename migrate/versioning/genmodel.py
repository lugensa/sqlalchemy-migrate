
# Code to generate a Python model from a database or differences between a model and database.
# Some of this is borrowed heavily from the AutoCode project at:  http://code.google.com/p/sqlautocode/

import sys
import sqlalchemy


HEADER = """
## File autogenerated by genmodel.py

from sqlalchemy import *
meta = MetaData()
"""

class ModelGenerator(object):

    def __init__(self, diff):
        self.diff = diff
        dialectModule = sys.modules[self.diff.conn.dialect.__module__]  # is there an easier way to get this?
        self.colTypeMappings = dict( (v,k) for k,v in dialectModule.colspecs.items() )
    
    def column_repr(self, col):
        kwarg = []
        if col.key != col.name: kwarg.append('key')
        if col.primary_key:
            col.primary_key = True  # otherwise it dumps it as 1
            kwarg.append('primary_key')
        if not col.nullable: kwarg.append('nullable')
        if col.onupdate: kwarg.append('onupdate')
        if col.default: kwarg.append('default')
        ks = ', '.join('%s=%r' % (k, getattr(col, k)) for k in kwarg )
            
        name = col.name.encode('utf8')  # crs: not sure if this is good idea, but it gets rid of extra u''
        #type = self.colTypeMappings[col.type.__class__]()
        type = self.colTypeMappings.get(col.type.__class__, None)
        if type:
            # Make the column type be an instance of this type.
            type = type()
        else:
            # We must already be a model type, no need to map from the database-specific types.
            type = col.type

        data = {'name' : name, 
                'type' : type,
                'constraints' : ', '.join([repr(cn) for cn in col.constraints]),
                'args' : ks and ks or ''
                }

        if data['constraints']:
            if data['args']: data['args'] = ',' + data['args']
        
        if data['constraints'] or data['args']:
            data['maybeComma'] = ','
        else:
            data['maybeComma'] = ''

        return """Column(%(name)r, %(type)r %(maybeComma)s %(constraints)s %(args)s)""" % data
    
    def getTableDefn(self, table):
        out = []
        tableName = table.name
        out.append("%(table)s = Table('%(table)s', meta," % {'table': tableName})
        for col in table.columns:
            out.append("  %s," % self.column_repr(col))
        out.append(")")
        return out
        
    def toPython(self):
        ''' Assume database is current and model is empty. '''
        out = []
        out.append(HEADER)
        out.append("")
        for table in self.diff.tablesMissingInModel:
            out.extend(self.getTableDefn(table))
            out.append("")
        return '\n'.join(out)
        
    def toUpgradePython(self, indent='    '):
        ''' Assume model is most current and database is out-of-date. '''
        
        decls = ['meta = MetaData(migrate_engine)']
        for table in self.diff.tablesMissingInModel + self.diff.tablesMissingInDatabase:
            decls.extend(self.getTableDefn(table))
            
        cmds = []
        for table in self.diff.tablesMissingInModel:
            tableName = table.name
            cmds.append("%(table)s.drop()" % {'table': tableName})
        for table in self.diff.tablesMissingInDatabase:
            tableName = table.name
            cmds.append("%(table)s.create()" % {'table': tableName})
            
        return '\n'.join(decls), '\n'.join(['%s%s' % (indent, line) for line in cmds])
    
    def toDowngradePython(self, indent='    '):
        return '    pass  #TODO DOWNGRADE'
    
